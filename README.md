# Расчет энергопотребления 50 зданий
## Задание: Рассчитать данные по энергопотреблению
### Инструкция
Загрузите данные и посчитайте модели линейной регрессии для 50 зданий по ансамблю регрессионных моделей: в первой модели весь оптимальный набор метеорологических данных, во второй - дни недели и праздники, в третьей - недели года, в четвертой - месяцы. 
Финальное значение показателя рассчитайте как взвешенное арифметическое среднее показателей всех моделей, взяв веса для первой и второй модели как 3/8, а для третьей и четвертой - как 1/8.
Загрузите данные решения, посчитайте значение энергопотребления для требуемых дат для тех зданий, которые посчитаны в модели, и выгрузите результат в виде CSV-файла (submission.csv).
Данные:
* http://video.ittensive.com/machine-learning/ashrae/building_metadata.csv.gz
* http://video.ittensive.com/machine-learning/ashrae/weather_train.csv.gz
* http://video.ittensive.com/machine-learning/ashrae/train.0.csv.gz
* http://video.ittensive.com/machine-learning/ashrae/test.csv.gz
* http://video.ittensive.com/machine-learning/ashrae/weather_test.csv.gz
Итоговый файл с кодом (.py или .ipynb) выложите в github с портфолио.
___
## Решение.
1) Подключим необходимые библиотеки.
2) Загрузим данных для расчета, оптимизируем память.
В целях оптимизации исходных данных максимально уменьшим объем памяти,  используя функцию оптимизации памяти. Проверим исходный тип данных и уменьшим его размер.
3) Загрузка данных для модели по 50 зданиям.
4) Интерполяция и обогащение данных по погоде.
- Вызовим функцию "weather_interpolate_diff" по параметру "weather"
- Произведем интерполяцию (сглаживание) данных по "weather"
- установим параметры: limit_direction='both' - интерполируются оба конца
- kind='cubic' - точки гладко соединяются кубическими полиномами
- используя функцию diff обогатим данные по погоде
5) Объединение данных с погодными.
- проиндексируем фрейм данных по "timestamp", "site_id";
- объединим данные по "energy" и "weather";
- сбросим индекс фрейма данных "energy";
- удалим столбцы с данными: "meter", "year_built","square_feet", "floor_count";
- фрейм данных «energy» оптимизируем в соответствии с условиями функции «def reduce_mem_usage (df)».
6)  Обогащение данных по датам и логарифмирование.
- Вызовим функцию "add_dates_log" по параметру "df";
- преобразуем массив значений по "hour", "weekday", "week", "month" в целочисленный 8 бит;
- преобразуем массив значений по "date" в формат DateTime;
- вычисляем соответсвие параметру "df" по "weekday", "week", "month";
- с помощью функции date_range() создадим диапазон дат с 2015-12-31 до 2018-06-01;
- с помощью функции calendar().holidays выделим выходные дни;
- произведем логарифмирование данных по столбцу "meter_reading";
-  завершаем выполнение вызова функции "df".
7) Расчет моделей линейной регрессии.
- сгенерируем списки "hours" (0-24) и "buildings" (0-50);
- Вызовим функцию "calculate_model_coeffs" по параметру "columns";
- заменим значения NaN на 0 во всех столбцах с помощью "fillna(0)";
- создадим параметр "coeffs" по колличеству домов "buildings";
- проработаем фрейм данных "buildings";
- создадим параметр "coeffs[building]" по колличеству домов "buildings" и времени "hours";
- рассчитаем данные по каждому часу каждого дома;
- рассчитаем энергопотребление по каждому часу;
- создаем модель линейной регрессии;
- объединим для массива данных "coeffs[building][hour]" и "model.intercept_";
- завершаем выполнение вызова параметра "coeffs";
- создадим миссив данных "lr_columns_weather" (погода);
- фрейм данных «lr_columns_weather» оптимизируем в соответствии с условиями функции "calculate_model_coeffs" (lr_columns_weather);  
- создадим миссив данных "lr_columns_days" (день);
- рассчитаем данные для каждого дня;
- фрейм данных «lr_columns_d» оптимизируем в соответствии с условиями функции "calculate_model_coeffs" (lr_columns_days);
- создадим миссив данных "lr_columns_weeks" (недели);
- рассчитаем данные для каждой недели;
- фрейм данных «lr_columns_ww» оптимизируем в соответствии с условиями функции "calculate_model_coeffs" (lr_columns_weeks);
- создадим миссив данных "lr_columns_monthes" (месяца);
- рассчитаем данные для каждой месяца;
- фрейм данных «lr_columns_m» оптимизируем в соответствии с условиями функции "calculate_model_coeffs" (lr_columns_monthes);
8) Удаление обучающих данных.
- удаляем обучающие данные "energy".
9) Подготовка данных для расчетов.
- загрузим данные для расчетов;
- используем данные по 50 зданиям;
- объединим данные по "results" и "buildings".
10)  Интерполяция значений и обогащение погодных данных: только для 1 города.
- фрейм данных «weather» оптимизируем в соответствии с условиями функции "weather_interpolate_diff(weather)".
11) Объединение данных по погоде.
- проиндексируем в таблицах данных "results" и "weather" по столбцам: "timestamp", "site_id";
- объединим массивы данных "results" и "weather";
- с помощью параметра how="left" мы указали, что главным является датафрейм слева, название столбца – «results»;
- сбросим индекс по данным "results";
- сгруппируем данные по столбцам: "meter", "site_id", "year_built","square_feet", "floor_count";
- удалим массив данных "weather";
- фрейм данных «results» оптимизируем в соответствии с условиями функции «def #reduce_mereduce_mem_usage(results)».
12) Обогащение данных по дате.
- фрейм данных «results» оптимизируем в соответствии с условиями функции «add_dates_log(results)».
13) Расчет финальных показателей, только энергопотребление, только 50 первых зданий.
- Вызовим функцию "calculate_model" по параметрам "x", "model", "columns";
- Вызовим функцию "calculate_ensemble" по параметру "x".
- преобразуем массив данных "results" по условиям функции "calculate_ensemble".
14) Усечение данных до требуемого формата: row_id, meter_reading - и выгрузка результата.
15) Загрузка всех данных для заполнения их нулями.
16) Выгрузка результатов в CSV файл.
17) Освобождение памяти.




